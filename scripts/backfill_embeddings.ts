#!/usr/bin/env -S deno run --allow-net --allow-env\n\n/**\n * Script de Backfill de Embeddings Gemini\n * \n * Este script deve ser executado uma √∫nica vez ap√≥s a migra√ß√£o do banco de dados.\n * Ele re-gera os embeddings para todos os n√≥s existentes com a nova dimensionalidade e tipo.\n * \n * ATEN√á√ÉO: Execute apenas em ambiente com as vari√°veis corretas configuradas!\n * \n * Uso:\n *   deno run --allow-net --allow-env scripts/backfill_embeddings.ts\n */\n\nimport { createClient } from 'https://esm.sh/@supabase/supabase-js@2.39.3';\n\n// Valida√ß√£o de vari√°veis de ambiente\nconst SUPABASE_URL = Deno.env.get('SUPABASE_URL');\nconst SUPABASE_SERVICE_ROLE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY');\nconst GEMINI_API_KEY = Deno.env.get('Gemini-Embedding') || Deno.env.get('Gemini_Embedding');\n\nif (!SUPABASE_URL || !SUPABASE_SERVICE_ROLE_KEY) {\n  console.error('‚ùå ERRO: Vari√°veis SUPABASE_URL e SUPABASE_SERVICE_ROLE_KEY s√£o obrigat√≥rias');\n  Deno.exit(1);\n}\n\nif (!GEMINI_API_KEY) {\n  console.warn('‚ö†Ô∏è  AVISO: Vari√°vel Gemini-Embedding n√£o encontrada. Usando embeddings zero.');\n}\n\nconst supabaseClient = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);\n\n// Fun√ß√£o de embedding Gemini\nasync function generateDocumentEmbedding(text: string): Promise<number[]> {\n  try {\n    if (!GEMINI_API_KEY) {\n      return Array(768).fill(0);\n    }\n\n    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/text-embedding-004:embedContent?key=${GEMINI_API_KEY}`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        model: \"models/text-embedding-004\",\n        content: {\n          parts: [{ text }]\n        },\n        taskType: \"RETRIEVAL_DOCUMENT\",\n        outputDimensionality: 768\n      }),\n    });\n\n    if (!response.ok) {\n      console.warn(`‚ö†Ô∏è  Gemini API error: ${response.status}, usando embedding zero`);\n      return Array(768).fill(0);\n    }\n\n    const result = await response.json();\n    const embedding = result.embedding.values;\n\n    if (!embedding || !Array.isArray(embedding)) {\n      console.warn('‚ö†Ô∏è  Resposta inv√°lida do Gemini, usando embedding zero');\n      return Array(768).fill(0);\n    }\n\n    // Normaliza√ß√£o\n    const norm = Math.sqrt(embedding.reduce((sum: number, val: number) => sum + val * val, 0));\n    if (norm === 0) return Array(768).fill(0);\n\n    const normalizedEmbedding = embedding.map((val: number) => val / norm);\n    \n    // Garantir 768 dimens√µes\n    if (normalizedEmbedding.length !== 768) {\n      if (normalizedEmbedding.length > 768) {\n        return normalizedEmbedding.slice(0, 768);\n      } else {\n        return [...normalizedEmbedding, ...Array(768 - normalizedEmbedding.length).fill(0)];\n      }\n    }\n\n    return normalizedEmbedding;\n\n  } catch (error) {\n    console.error(`‚ùå Erro no embedding Gemini:`, error);\n    return Array(768).fill(0);\n  }\n}\n\n// Fun√ß√£o principal de backfill\nasync function backfillEmbeddings() {\n  console.log('üöÄ Iniciando backfill de embeddings com gemini-embedding-001 (768d)...');\n  \n  try {\n    // Buscar todos os n√≥s existentes\n    const { data: nodes, error } = await supabaseClient\n      .from('nodes')\n      .select('id, label, properties, type, created_at')\n      .order('created_at', { ascending: true }); // Processar dos mais antigos para os mais novos\n      \n    if (error) {\n      throw new Error(`Erro ao buscar n√≥s: ${error.message}`);\n    }\n\n    if (!nodes || nodes.length === 0) {\n      console.log('‚ÑπÔ∏è  Nenhum n√≥ encontrado para processar.');\n      return;\n    }\n\n    console.log(`üìä Encontrados ${nodes.length} n√≥s para re-processar.`);\n    console.log('‚è≥ Iniciando processamento...');\n    \n    let processed = 0;\n    let errors = 0;\n    const batchSize = 10; // Processar em lotes para evitar rate limiting\n    \n    for (let i = 0; i < nodes.length; i += batchSize) {\n      const batch = nodes.slice(i, i + batchSize);\n      \n      console.log(`üîÑ Processando lote ${Math.floor(i / batchSize) + 1}/${Math.ceil(nodes.length / batchSize)} (${batch.length} n√≥s)`);\n      \n      // Processar lote em paralelo\n      const promises = batch.map(async (node) => {\n        try {\n          // Preparar texto para embedding\n          const textToEmbed = `${node.label || ''} ${JSON.stringify(node.properties || {})}`;\n          \n          if (textToEmbed.trim().length === 0) {\n            console.warn(`‚ö†Ô∏è  N√≥ ${node.id} tem conte√∫do vazio, pulando...`);\n            return { success: false, nodeId: node.id, reason: 'empty_content' };\n          }\n          \n          // Gerar novo embedding\n          const newEmbedding = await generateDocumentEmbedding(textToEmbed);\n          \n          // Atualizar no banco\n          const { error: updateError } = await supabaseClient\n            .from('nodes')\n            .update({ \n              embedding: newEmbedding, \n              updated_at: new Date().toISOString()\n            })\n            .eq('id', node.id);\n            \n          if (updateError) {\n            throw updateError;\n          }\n          \n          return { success: true, nodeId: node.id };\n          \n        } catch (error) {\n          console.error(`‚ùå Erro ao processar n√≥ ${node.id}:`, error.message);\n          return { success: false, nodeId: node.id, error: error.message };\n        }\n      });\n      \n      // Aguardar conclus√£o do lote\n      const results = await Promise.all(promises);\n      \n      // Contar resultados\n      results.forEach(result => {\n        if (result.success) {\n          processed++;\n          if (processed % 25 === 0) {\n            console.log(`‚úÖ ${processed} n√≥s processados com sucesso`);\n          }\n        } else {\n          errors++;\n        }\n      });\n      \n      // Pequena pausa entre lotes para evitar rate limiting\n      if (i + batchSize < nodes.length) {\n        await new Promise(resolve => setTimeout(resolve, 1000));\n      }\n    }\n    \n    console.log('\\nüéâ Backfill de embeddings conclu√≠do!');\n    console.log(`üìà Estat√≠sticas:`);\n    console.log(`   ‚úÖ N√≥s processados com sucesso: ${processed}`);\n    console.log(`   ‚ùå N√≥s com erro: ${errors}`);\n    console.log(`   üìä Total de n√≥s: ${nodes.length}`);\n    console.log(`   üéØ Taxa de sucesso: ${((processed / nodes.length) * 100).toFixed(1)}%`);\n    \n    if (errors > 0) {\n      console.log(`\\n‚ö†Ô∏è  ${errors} n√≥s falharam. Verifique os logs acima para detalhes.`);\n    }\n    \n  } catch (error) {\n    console.error('üí• Erro fatal durante o backfill:', error);\n    Deno.exit(1);\n  }\n}\n\n// Fun√ß√£o para validar a estrutura do banco\nasync function validateDatabase() {\n  console.log('üîç Validando estrutura do banco de dados...');\n  \n  try {\n    // Verificar se a tabela nodes existe e tem a estrutura correta\n    const { data, error } = await supabaseClient\n      .from('nodes')\n      .select('id')\n      .limit(1);\n      \n    if (error) {\n      throw new Error(`Erro ao acessar tabela nodes: ${error.message}`);\n    }\n    \n    console.log('‚úÖ Tabela nodes acess√≠vel');\n    \n    // Verificar se a fun√ß√£o hybrid_search existe\n    const { error: funcError } = await supabaseClient\n      .rpc('hybrid_search', {\n        query_text: 'teste',\n        query_embedding: Array(768).fill(0),\n        match_count: 1\n      });\n      \n    if (funcError && !funcError.message.includes('no rows')) {\n      console.warn(`‚ö†Ô∏è  Fun√ß√£o hybrid_search pode ter problemas: ${funcError.message}`);\n    } else {\n      console.log('‚úÖ Fun√ß√£o hybrid_search dispon√≠vel');\n    }\n    \n  } catch (error) {\n    console.error('‚ùå Erro na valida√ß√£o do banco:', error);\n    throw error;\n  }\n}\n\n// Fun√ß√£o principal\nasync function main() {\n  console.log('üéØ BACKFILL DE EMBEDDINGS GEMINI - ERASMOINVEST');\n  console.log('================================================\\n');\n  \n  try {\n    await validateDatabase();\n    \n    console.log('\\n‚ö†Ô∏è  ATEN√á√ÉO: Este processo ir√° re-gerar TODOS os embeddings existentes.');\n    console.log('   Isso pode demorar v√°rios minutos dependendo da quantidade de dados.');\n    console.log('   Certifique-se de que:');\n    console.log('   1. A migration 768d j√° foi aplicada');\n    console.log('   2. A vari√°vel Gemini-Embedding est√° configurada');\n    console.log('   3. Voc√™ tem conectividade com a internet\\n');\n    \n    // Prompt de confirma√ß√£o (simulado - em produ√ß√£o poderia usar input)\n    console.log('üöÄ Iniciando em 3 segundos...');\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    console.log('‚è≥ 2...');\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    console.log('‚è≥ 1...');\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    \n    await backfillEmbeddings();\n    \n    console.log('\\nüéâ Processo conclu√≠do com sucesso!');\n    console.log('üí° Pr√≥ximos passos:');\n    console.log('   1. Teste a busca h√≠brida no cognitive-core');\n    console.log('   2. Monitore os logs de performance');\n    console.log('   3. Execute os ingestores para gerar novos dados\\n');\n    \n  } catch (error) {\n    console.error('üí• Falha no processo de backfill:', error);\n    Deno.exit(1);\n  }\n}\n\n// Executar se chamado diretamente\nif (import.meta.main) {\n  main();\n}