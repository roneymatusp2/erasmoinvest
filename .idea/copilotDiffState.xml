<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/generate-tree.ps1">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/generate-tree.ps1" />
              <option name="originalContent" value="# Script para gerar árvore de arquivos do projeto&#10;# Exclui pastas de build, dependências e arquivos temporários&#10;&#10;param(&#10;    [string]$Path = &quot;.&quot;,&#10;    [string]$OutputFile = &quot;project-tree.txt&quot;&#10;)&#10;&#10;function Get-ProjectTree {&#10;    param(&#10;        [string]$CurrentPath,&#10;        [string]$Prefix = &quot;&quot;,&#10;        [int]$Depth = 0&#10;    )&#10;&#10;    # Pastas e arquivos a serem excluídos&#10;    $ExcludedFolders = @(&#10;        &quot;node_modules&quot;, &quot;dist&quot;, &quot;build&quot;, &quot;.git&quot;, &quot;.vscode&quot;, &quot;.idea&quot;,&#10;        &quot;.next&quot;, &quot;.nuxt&quot;, &quot;coverage&quot;, &quot;.nyc_output&quot;, &quot;tmp&quot;, &quot;temp&quot;,&#10;        &quot;.cache&quot;, &quot;.parcel-cache&quot;, &quot;.claude&quot;&#10;    )&#10;&#10;    $ExcludedFiles = @(&#10;        &quot;*.log&quot;, &quot;*.tmp&quot;, &quot;*.lock&quot;, &quot;package-lock.json&quot;, &quot;yarn.lock&quot;,&#10;        &quot;*.cache&quot;, &quot;*.pid&quot;, &quot;*.seed&quot;, &quot;*.pid.lock&quot;, &quot;*.tgz&quot;, &quot;*.tar.gz&quot;&#10;    )&#10;&#10;    # Limita a profundidade para evitar loops infinitos&#10;    if ($Depth -gt 10) { return }&#10;&#10;    try {&#10;        $Items = Get-ChildItem -Path $CurrentPath -Force | Where-Object {&#10;            $item = $_&#10;&#10;            # Verifica se é pasta excluída&#10;            if ($item.PSIsContainer) {&#10;                return $ExcludedFolders -notcontains $item.Name&#10;            }&#10;&#10;            # Verifica se é arquivo excluído&#10;            $isExcluded = $false&#10;            foreach ($pattern in $ExcludedFiles) {&#10;                if ($item.Name -like $pattern) {&#10;                    $isExcluded = $true&#10;                    break&#10;                }&#10;            }&#10;            return -not $isExcluded&#10;        }&#10;&#10;        $Items = $Items | Sort-Object PSIsContainer, Name&#10;&#10;        for ($i = 0; $i -lt $Items.Count; $i++) {&#10;            $item = $Items[$i]&#10;            $isLast = ($i -eq ($Items.Count - 1))&#10;&#10;            if ($isLast) {&#10;                $currentPrefix = &quot;└── &quot;&#10;                $nextPrefix = $Prefix + &quot;    &quot;&#10;            } else {&#10;                $currentPrefix = &quot;├── &quot;&#10;                $nextPrefix = $Prefix + &quot;│   &quot;&#10;            }&#10;&#10;            if ($item.PSIsContainer) {&#10;                Write-Output &quot;$Prefix$currentPrefix$($item.Name)/&quot;&#10;                Get-ProjectTree -CurrentPath $item.FullName -Prefix $nextPrefix -Depth ($Depth + 1)&#10;            } else {&#10;                Write-Output &quot;$Prefix$currentPrefix$($item.Name)&quot;&#10;            }&#10;        }&#10;    }&#10;    catch {&#10;        Write-Warning &quot;Erro ao acessar: $CurrentPath - $($_.Exception.Message)&quot;&#10;    }&#10;}&#10;&#10;# Gera o cabeçalho&#10;$ProjectName = Split-Path -Leaf (Get-Location)&#10;$Header = @&quot;&#10;ESTRUTURA DO PROJETO: $ProjectName&#10;Gerado em: $(Get-Date -Format &quot;dd/MM/yyyy HH:mm:ss&quot;)&#10;===============================================&#10;&#10;$ProjectName/&#10;&quot;@&#10;&#10;# Gera a árvore&#10;Write-Host &quot;Gerando estrutura em árvore do projeto...&quot; -ForegroundColor Green&#10;$TreeOutput = Get-ProjectTree -CurrentPath $Path&#10;&#10;# Combina cabeçalho e árvore&#10;$FullOutput = $Header + &quot;`n&quot; + ($TreeOutput -join &quot;`n&quot;)&#10;&#10;# Salva no arquivo&#10;$FullOutput | Out-File -FilePath $OutputFile -Encoding UTF8&#10;&#10;Write-Host &quot;Estrutura salva em: $OutputFile&quot; -ForegroundColor Green&#10;Write-Host &quot;Total de linhas: $($TreeOutput.Count + 4)&quot; -ForegroundColor Cyan&#10;&#10;# Mostra preview das primeiras linhas&#10;Write-Host &quot;`nPreview das primeiras linhas:&quot; -ForegroundColor Yellow&#10;$FullOutput -split &quot;`n&quot; | Select-Object -First 20 | ForEach-Object { Write-Host $_ }&#10;&#10;if ($TreeOutput.Count -gt 16) {&#10;    Write-Host &quot;...&quot; -ForegroundColor Gray&#10;    Write-Host &quot;Arquivo completo salvo em $OutputFile&quot; -ForegroundColor Green&#10;}&#10;" />
              <option name="updatedContent" value="# Script para gerar árvore de arquivos do projeto&#10;# Exclui pastas de build, dependências e arquivos temporários&#10;&#10;param(&#10;    [string]$Path = &quot;.&quot;,&#10;    [string]$OutputFile = &quot;project-tree.txt&quot;&#10;)&#10;&#10;function Get-ProjectTree {&#10;    param(&#10;        [string]$CurrentPath,&#10;        [string]$Prefix = &quot;&quot;,&#10;        [int]$Depth = 0&#10;    )&#10;    &#10;    # Pastas e arquivos a serem excluídos&#10;    $ExcludedFolders = @(&#10;        &quot;node_modules&quot;, &quot;dist&quot;, &quot;build&quot;, &quot;.git&quot;, &quot;.vscode&quot;, &quot;.idea&quot;, &#10;        &quot;.next&quot;, &quot;.nuxt&quot;, &quot;coverage&quot;, &quot;.nyc_output&quot;, &quot;tmp&quot;, &quot;temp&quot;,&#10;        &quot;.cache&quot;, &quot;.parcel-cache&quot;, &quot;.claude&quot;&#10;    )&#10;    &#10;    $ExcludedFiles = @(&#10;        &quot;*.log&quot;, &quot;*.tmp&quot;, &quot;*.lock&quot;, &quot;package-lock.json&quot;, &quot;yarn.lock&quot;,&#10;        &quot;*.cache&quot;, &quot;*.pid&quot;, &quot;*.seed&quot;, &quot;*.pid.lock&quot;, &quot;*.tgz&quot;, &quot;*.tar.gz&quot;&#10;    )&#10;    &#10;    # Limita a profundidade para evitar loops infinitos&#10;    if ($Depth -gt 10) { return }&#10;    &#10;    try {&#10;        $Items = Get-ChildItem -Path $CurrentPath -Force | Where-Object {&#10;            $item = $_&#10;            &#10;            # Verifica se é pasta excluída&#10;            if ($item.PSIsContainer) {&#10;                return $ExcludedFolders -notcontains $item.Name&#10;            }&#10;            &#10;            # Verifica se é arquivo excluído&#10;            $isExcluded = $false&#10;            foreach ($pattern in $ExcludedFiles) {&#10;                if ($item.Name -like $pattern) {&#10;                    $isExcluded = $true&#10;                    break&#10;                }&#10;            }&#10;            return -not $isExcluded&#10;        }&#10;        &#10;        $Items = $Items | Sort-Object PSIsContainer, Name&#10;        &#10;        for ($i = 0; $i -lt $Items.Count; $i++) {&#10;            $item = $Items[$i]&#10;            $isLast = ($i -eq ($Items.Count - 1))&#10;            &#10;            if ($isLast) {&#10;                $currentPrefix = &quot;+-- &quot;&#10;                $nextPrefix = $Prefix + &quot;    &quot;&#10;            } else {&#10;                $currentPrefix = &quot;|-- &quot;&#10;                $nextPrefix = $Prefix + &quot;|   &quot;&#10;            }&#10;            &#10;            if ($item.PSIsContainer) {&#10;                Write-Output &quot;$Prefix$currentPrefix$($item.Name)/&quot;&#10;                Get-ProjectTree -CurrentPath $item.FullName -Prefix $nextPrefix -Depth ($Depth + 1)&#10;            } else {&#10;                Write-Output &quot;$Prefix$currentPrefix$($item.Name)&quot;&#10;            }&#10;        }&#10;    }&#10;    catch {&#10;        Write-Warning &quot;Erro ao acessar: $CurrentPath - $($_.Exception.Message)&quot;&#10;    }&#10;}&#10;&#10;# Gera o cabeçalho&#10;$ProjectName = Split-Path -Leaf (Get-Location)&#10;$Header = @&quot;&#10;ESTRUTURA DO PROJETO: $ProjectName&#10;Gerado em: $(Get-Date -Format &quot;dd/MM/yyyy HH:mm:ss&quot;)&#10;===============================================&#10;&#10;$ProjectName/&#10;&quot;@&#10;&#10;# Gera a árvore&#10;Write-Host &quot;Gerando estrutura em árvore do projeto...&quot; -ForegroundColor Green&#10;$TreeOutput = Get-ProjectTree -CurrentPath $Path&#10;&#10;# Combina cabeçalho e árvore&#10;$FullOutput = $Header + &quot;`n&quot; + ($TreeOutput -join &quot;`n&quot;)&#10;&#10;# Salva no arquivo&#10;$FullOutput | Out-File -FilePath $OutputFile -Encoding UTF8&#10;&#10;Write-Host &quot;Estrutura salva em: $OutputFile&quot; -ForegroundColor Green&#10;Write-Host &quot;Total de linhas: $($TreeOutput.Count + 4)&quot; -ForegroundColor Cyan&#10;&#10;# Mostra preview das primeiras linhas&#10;Write-Host &quot;`nPreview das primeiras linhas:&quot; -ForegroundColor Yellow&#10;$FullOutput -split &quot;`n&quot; | Select-Object -First 20 | ForEach-Object { Write-Host $_ }&#10;&#10;if ($TreeOutput.Count -gt 16) {&#10;    Write-Host &quot;...&quot; -ForegroundColor Gray&#10;    Write-Host &quot;Arquivo completo salvo em $OutputFile&quot; -ForegroundColor Green&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>